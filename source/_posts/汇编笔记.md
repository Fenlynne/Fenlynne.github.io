---
title: 汇编笔记
date: 2019-08-15 10:08:18
tags:
---

## 1. 基础

1.1 整数表示

tips: 带符号数除以2的幂等价于(x + 1<<k - 1) >> k
1.2 浮点数表示

## 2. X86汇编与Ｃ语言

### 2.1 X86_64指令的特点

#### 2.1.1 数据格式

| 后缀suffix | 名称name     | 大小size |
| ---------- | ------------ | -------- |
| b          | 字节byte     | 1 byte   |
| w          | 字word       | 2 bytes  |
| l          | 双字long     | 4 bytes  |
| q          | 四字quadword | 8 bytes  |

#### 2.1.2 寻址方式

> D(Rb, Ri, S) 表示　Ｍem[Reg[Rb] + S*Reg[Ri]+D]
>
> D: 常量表示地址偏移量
>
> Rb: 基址寄存器
>
> Ri: 索引寄存器　[排除%rsp]
>
> S: 比例因子, 通常为数据格式的大小

#### 2.1.3 常用指令

1. **movq S D**

   将S的值赋给D

2. **leaq S D** 

   从地址计算表达式S计算出地址赋给D 

   另类常用用法: 计算x+k*y类型的整数运算

3. **sarq S D**

   D >>= S

   a/h 表示　算数/逻辑

   r/l 表示右移/左移



### 2.2 条件码

#### 2.2.1 符号表示

> **CF**		进位标志Carry Flag
>
> **ZF**		判零标志Zero Flag
>
> **SF**		判负标志Sign Flag
>
> **OF**	   补码溢出标志Overflow Flag



这些条件码由算数指令隐含设置(add, sub, cmp...不包括leaq)

**比较指令** cmp b a 

​	类似于计算a-b, 然后设置条件码

**测试指令** testq b a 

​	计算 a&b



#### 2.2.2 读取条件码

**SetX 指令**

> *signed*: setg, setge, setl, setle
>
> *unsigned*: seta, setb



```assembly
SetX S
movzbl S D
读取当前条件码并存入目的"字节"寄存器 S
使用**movzbl**对目的寄存器进行0扩展: S存入D的低字节, 高8补0?？

jX S
条件跳转, 功能是根据条件码选择下一条执行语句

cmovX S D
条件移动, 若X满足, 则 D = S
注意: 若操作数中有地址表达式,则先访存, 后比较
```

### 2.3 循环控制

#### 2.3.1 do-while

```c
# C Code
long pcount_do(unsigned long x) {
	long result = 0;
    do {
        result += x & 0x1;
        x >>= 1;
    } while (x);
    return result;
}

# Goto version
long pcount_goto(unsigned long x) {
    long result = 0;
    loop:
    result += x & 0x1;
    x >>= 1;
    if(x) goto loop;
    	return result;
}
```

经过编译后

```assembly
	movl $0, %eax 			# result = 0
.L2:						# loop:
    movq %rdi, %rdx
    andl $1, %edx			# t = x & 0x1
    addq %rdx, %rax			# result += t
    shrq %rdi				#x >>= 1
    jne .L2					# if (x) goto loop
rep; ret
```



#### 2.3.2 while-do

```c
# C Code
long pcount_while(unsigned long x) {
    long result = 0;
    while (x) {
        result += x & 0x1;
        x >>= 1;
    }
    return result;
}

long pcount_goto_jtm (unsigned long x) {
    long result = 0;
    goto test;
    loop:
        result += x & 0x1;
        x >>= 1;
    test:
    	if(x) goto loop;
    return result;
}

```

转换成do-while会增加条件跳转指令, 引起性能损失

#### 2.3.3 for

转换成while-do

#### 2.3.4 switch

​	

### 2.4 过程调用

>  假设过程P调用过程Q, Q执行后返回到P, , 这些动作包括下面一个或多个机制
>
> - 传递控制
>
>   - 进入过程Q时, 程序计数器(%rip)必须设置为Q的代码的起始地址
>   - 从过程Q返回时, 把%rip设置为P中调用Q后面那条指令的地址
>
> - 传递数据
>
>   - P向Q传递参数, Q向P返回一个值
>
> - 分配和释放内存
>
>   - 开始时Q为局部变量分配空间, 返回时释放
>
>   

#### 2.4.1 栈帧

![1566089645438](/home/ljf/.config/Typora/typora-user-images/1566089645438.png)

>  当P需要调用Q时, 需要的操作依次为
>
> 准备参数->返回地址(调用语句下一条指令)压栈->%rsp下拉分配空间->保存寄存器(可选)
>
> 参数构造区?

### 2.5 汇编编程

#### 2.5.1 程序链接

**全局符号**

**外部符号**　extern声明的全局变量及外部函数

**局部符号**　局部变量和static变量

将不同目标文件的正文段, 数据段等拼接到一起

## MIPS
